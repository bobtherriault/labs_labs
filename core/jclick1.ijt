LABTITLE=: 'J By Point & Click I'
LABFOCUS=: 1

NB. =========================================================
Lab Chapter The J Session
NB. =========================================================
Lab Section Term window
In this lab you will teach yourself J by watching J code run and by exploring the documentation.

You will have five windows into your J session.  The first is the window you are looking at.  It is called the term window.  You type sentences here to have them executed, and the results are typed back here.

Type the string

   1+2+3+4+5

into this window and press ENTER.  The result will be typed below your input.

To advance to the next section, come back to this term window and press ctrl+J.

NOTE: In this lab, parentheses are used to indicate J code.
)
PREPARE
load '~addons/labs/labs/core/jpcfmt.ijs'
PREPARE

NB. =========================================================
Lab Section Edit window
Your second window into J is the edit window, shown here.

The edit window is a tabbed text editor for J source code.

In normal use you will open a tab for a file using the File|Open menu.  This lab will manage the tabs for you as you progress.
)
PREPARE
_1 0 loadedittab 0 : 0
NB. Since J is interpreted, there is no compilation step for J
NB. programs.  If you have program definitions that you want to
NB. execute, you load them by pressing the green arrow above (or
NB. by pressing ctrl+L).

NB. A file containing J sentences, like this one, is called a
NB. script.  All the sentences in this script are comments,
NB. which start with NB.

NB. Loading a script feeds the lines of the script one by one
NB. into the term window, where they are executed as if you had
NB. typed them in by hand.

NB. Each tab in the edit window is associated with a file, whose
NB. name can be seen in the tab.  Loading a tab first writes the
NB. contents of the tab to the file, then loads the file.
)
PREPARE
NB. =========================================================
Lab Section Debug window
The third window is the debug window.  Right now it's just a little bar in the upper-right of your screen.  It will get bigger when it has something to say.

In normal use you summon up the debug window by pressing ctrl+K.  This lab will manage the debugger for you.
)
PREPARE
jdb_open_jdebug_ ''
PREPARE
NB. =========================================================
Lab Section Dissect window
We have loaded a script into the edit window, and set a stop in the debugger.  Then we ran a program, which executed until it hit the stop.

Hitting the stop brought up the colorful dissect window.  A single sentence in J can do an enormous amount of computation, so much that you need to see it all laid out at once to understand it.

The dissect window shows you the execution of a single sentence, with the inputs coming in at the top and the results going out at the bottom.  By clicking and hovering over parts of the dissect display, you can learn what a sentence is doing.
)
PREPARE
opendebscript 0 : 0
NB. Find shortest name
NB. y is a list of boxes, each containing a string
NB. Result is (unboxed ) shortest string
findshortestname =: verb define
NB.~stop 1
NB.~title 3	Find Shortest Name
NB. get length of each string
NB.~title1 0	Get lengths
NB.~link1 0	Assignment	http://www.jsoftware.com/jwiki/Vocabulary/Assignment
NB.~link2 0	Arrays	http://www.jsoftware.com/jwiki/Vocabulary/ArrayProcessing
NB.~link3 0	Modifiers	http://www.jsoftware.com/jwiki/Vocabulary/Modifiers
lengths =. #@> y
NB. Find smallest length, and its index
NB.~stop
NB.~title1 0	Get index of smallest length
smallindex =. lengths i. <./ lengths
NB. Extract that string to give the result
NB.~title1 0	Select smallest string
NB.~link1
smallindex {:: y
))
) 
PREPARE
findshortestname 'Jeb';'Hillary';'George';'Bill'

NB. =========================================================
Lab Section The debug window at a stop
Look again at the debug window.  It has come to life.  It has three panes now.

The top pane shows the lines of the definition that is running.  The > shows the next line to be executed.  The * shows that there is a stop on that line.

The middle pane shows the call stack: the programs that were called on the way to the line being debugged.  In this case, most of them are in the Labs Manager.

The bottom pane shows the values of names that will be referred to in the sentence.

The dissect window shows you what will happen when the sentence is executed.
)

NB. =========================================================
Lab Section Your browser
You will be getting most of your information about J through your browser.  The dissect window has fields that you can click on to get more information:

At the top-left of the dissect display is a list of links on topics relevant to the example.  Click to read.

In the display of the executing sentence, the top of each block shows what is executed in the block, in white type on a burgundy background.  If you click on these blocks your browser will show you the relevant documentation.

Click around in the dissect window to see what you can bring up in your browser.

You are now ready to explore J.  To watch execution, use the leftmost debugger button (Run) to run to the next stop, or the third-from-left button (Step Over) to run one line.
)
NB. =========================================================
Lab Chapter Word, Character, and Line Count
NB. =========================================================
Lab Section The Program
Here is a program to count characters, words, and lines in a file.

Before you try to analyze it, learn the essential terms of J.  Click on the link in the first dissect screen.

In J, a noun is a piece of data, and a verb is a function that operates on one or two nouns.

Nouns have shapes - corresponding to dimensions in other languages.  The the dissect display, the shape of a noun appears above its value.

Nouns have types - numeric, character, and boxed.  The special boxed type is a container that holds other nouns.

An atom is a noun that is not an array.  It can be of any type: a single number, a single character, or a single box.

As you step through this lab using ctrl-J, the lab will give a brief discussion of each line and automatically move the debugger through the lines.  Your job is to click around the dissect window and develop an idea for what's going on.
)
PREPARE
opendebscript 0 : 0
NB. Word Count

NB. y is a filename
NB. Result is a list:
NB. (#bytes),(#words),(#lines)
NB. where a word is defined as a non-whitespace preceded
NB.  by a whitespace
wc =: verb define
NB.~stop 1
NB.~title 3	Word Count
NB. Box the filename and Read the file
NB.~title1 0	Read the file
NB.~link3 0	Essential Terms	http://www.jsoftware.com/jwiki/Vocabulary/AET
NB.~link0 0	Assignment	http://www.jsoftware.com/jwiki/Vocabulary/Assignment
NB.~link1 0	Files	http://www.jsoftware.com/jwiki/Vocabulary/Foreigns#m1
filedata =. 1!:1 <y
NB. Count characters
NB.~title1 0	Count bytes
NB.~link1
cc =. #filedata
NB. Count lines
NB.~title1 0	Count lines
NB.~link2 0	Arrays	http://www.jsoftware.com/jwiki/Vocabulary/ArrayProcessing
lc =. +/ LF = filedata
NB. Classify each character as whitespace or not
NB.  add a whitespace to the beginning to ensure first word counted
NB.~title1 0	Classify whitespace
ws =. 1 , filedata e. ' ',TAB,CR,LF
NB. Count nonwhite preceded by white
NB.~title1 0	Count words
wc =. +/ ws > 1 |. ws
NB. Return results
NB.~title1 0	Result
NB.~link0
NB.~link2
cc,wc,lc
))
) 
PREPARE
wc jpath '~addons/labs/labs/core/lorem.txt'

NB. =========================================================
Lab Section Invoking wc
The program was started by executing the sentence

wc jpath '~addons/labs/labs/core/lorem.txt'

In this sentence, the quoted string is a noun and the names (wc) and (jpath) are verbs.  [(wc) is the verb we are analyzing; (jpath) is a library verb that translates the '~addons' to the path to your Addons directory.]

All J sentences are executed right-to-left.  A verb is executed by giving its name followed by a noun on its right.  The noun becomes an argument to the verb - and if there is a noun to the verb's left, that noun becomes a second argument to the verb.  [A verb always takes one or two arguments.]

In this case, (jpath) does not have a noun to its left, so it is executed with the string as its sole argument.  The result from (jpath) then becomes the sole argument of (wc) which is executed next.
)

NB. =========================================================
Lab Section Read the file
Executing wc means reading the sentences of its definition one by one and executing them.

Before execution starts, the value of the noun that appeared to the right of (wc) is assigned to the name (y).  If there had been a noun to the left of (wc), its value would have been assigned to the name (x).

[Since there are only one or two arguments to a J verb, there is no need for a declaration of parameters: the arguments just go by the names (x) and (y).]

In the first line, the contents of the file are read and assigned to the name (filedata).

(=.) performs assignment to a private name, i. e. a name used only inside the verb.

(1!:1) is a verb that reads a file.  It requires that the filename be boxed.

(<) is a verb that puts its argument into a box.

When the line finishes, (filedata) is a noun that contains a one-dimensional array of characters.

A one-dimensional array is called a list.  (filedata) is a list of characters.
)

NB. =========================================================
Lab Section Count bytes
(#) is a verb that tells how many items are in its argument.
)
debugstep''

NB. =========================================================
Lab Section Count lines
Every line ends with a linefeed [LF character], so the number of lines is the number of LFs.

The J way to find this is to compare each character of filedata against LF: this produces a Boolean value, 0 or 1, for each character; then add up the numbers to see how many 1s there were.

(+/) is a verb that adds all the items of its argument.

Note that the Boolean value for a true comparison is the number 1; false is 0.  The results of comparisons can be added and multiplied just like any other number.
)
debugstep''

NB. =========================================================
Lab Section Classify whitespace
Whitespace is any of space, TAB, LF, and CR.  We create a list containing those characters, and then check each character of (filedata) to see if it is whitespace.  Again, the result is a Boolean list, 1 if the character is whitespace.

Since we are going to recognize a word as a whitespace followed by a non-whitespace, we prepend a 1 to the list so that if the first character is non-whitespace it will be recognized as starting a word.  [Observe in the dissect screen that the length of the list grows by 1.]

The name (ws) holds the whitespace information.
)
debugstep''

NB. =========================================================
Lab Section Count words
A word is whitespace followed by a non-whitespace.  We create a rotated list, where each whitespace value is moved one position towards the beginning of the list.  The start of a word is a place where the whitespace list is 1 and the rotated list is 0, in other words when the whitespace list is greater than the rotated list.  Then we add up the number of word-starts.
)
debugstep''

NB. =========================================================
Lab Section Result
The result of the last line of the verb becomes the result of the overall verb.

Here we combine the counts to produce the desired result.
)
debugstep''

NB. =========================================================
Lab Section completion
)
debugstop''

NB. =========================================================
Lab Chapter Where are the loops?
NB. =========================================================
Lab Section The Zen of J
The J program to count words and characters is very different from a corresponding program in a scalar language.  The J programmer thinks about the problem as a whole, rather than immediately considering individual characters, counters, and loops.

For example, to find the places where words start, we didn't say, "look at every position and see if there is whitespace before and non-whitespace after."  Instead, we said, "create a value for each character that indicates whitespace; create another that indicates following whitespace; words start where the first is 1 and the second is 0."

Both of those approaches imply loops, but the first is more customized than the second.  The first approach is a loop over the concept of "position" which requires a specific computation at each position, and it really requires a loop index to keep the computation straight.

The second approach doesn't depend on "position".  It loops over portions of the data, performing an operation on each.  It can be described in terms of the data alone.

This is the J point of view.

Ken Iverson, after a lifetime of thinking about computation, selected a set of ways of looking at data that allow succinct yet complete descriptions of how to view, arrange, and manipulate data.  That's J.
)
NB. =========================================================
Lab Section The organization of nouns
The most important way data is organized is along coordinate axes.  An operation on an entire array is usually broken into a set of operations on parts of the array.  For example, comparing two characters is an operation on atoms, but if two strings are compared, the (=) verb is automatically applied between corresponding atoms.

The list of lengths of coordinate axes is called the "shape" of a noun.  The verb ($) produces the shape of its argument.

The number of axes is called the "rank" of the noun.  The rank is therefore the length of the shape.  The verb (#) produces the number of items in a noun, and (# $ y) gives the rank of the noun (y).

A "k-cell" of an array is a subarray of rank k, taking a slice along the last k axes.

For example, a 1-cell of a table is a row of the table: a list taken by a slice along the last axis.

A 1-cell of a 3-dimensional array is a row of one of the tables that make up the array.

A 0-cell is always an atom.

An array can be thought of as an array of its cells, in different ways: A 3x2x4 array can be thought of as a single brikc, or as 3 tables, each 2x4; or as a 3x2 array of lists, each of length 4; or as a 3x2x4 array of atoms.

The picture shows these different interpretations.  The verb (|.) reverses the order of the items of its argument.  (|."3) reverses the order inside the 3-cells, that is, it reverses the order of the 2-cells [tables]; (|."2) reverses the order of lists within each 2-cell; (|."1) reverses the order of atoms in each list; (|."0) does nothing because reversing an atom doesn't change anything.

As the processing flows from top to bottom you can see the action of the different verbs.  Click in a result to see what the argument- and result-cells were.
)
PREPARE
opendebscript 0 : 0
cells =: verb define
NB.~stop 1
NB.~title 3	3-, 2-, 1-, and 0-cells
|."3 |."2 |."1 |."0 y
))
)
PREPARE
'abc' = 'aca'
cells 3 2 4 $ 'abcdefghijklmnopqrstuvwx'

NB. =========================================================
Lab Section The rank of verbs
Every noun has a rank - the number of axes.

An array can be construed as an array of cells of lower rank.

You can control how a verb is executed by specifying the rank of the cells it will operate on.  You do this by following the verb with ("n) where (n) is the rank of the cells you want the verb to be applied to.  (u"n) is a "derived verb" that operates like (u), but it is applied to n-cells.

(n) is said to be the "rank" of (u"n).  The word "rank" has different meanings when applied to nouns and verbs.

We used (|.n) to create the display of cells.  Cells of different ranks were reversed.
)

NB. =========================================================
Lab Section Left and right rank
If a verb takes two arguments, a rank can be specified for each.  (u"1 2) means that (u) is applied between 1-cells [i. e. lists] of (x) and 2-cells [i. e. tables] of (y).

Exercises:
Experiment with the verb (x |. y).  It rotates the array (y) left/up (x) positions.  Use the array (c) defined below.

Then, use (c), (|.), and (") to create the array

toti
emul
esto 
)
debugstop''
]c =: 3 4 $ 'otitlemustoe'

NB. =========================================================
Lab Section Assembly of results
Here's the solution.  Click on results to see how result-cells were generated.

The execution of a verb automatically implies execution on multiple cells, depending on the rank of the verb.  These cells will have been ordered as an array, and the results of the execution are ordered the same way.  This ordering, which is taken from the leading axes of the argument-shape and becomes the leading axes of the result-shape, is called the "frame".

In the example shown, the verb (|.) is executed 3 times, with a frame of (3).  Each result is a list [of 4 characters], so the overall result is a list of lists, with shape (3 4).

The verb (+/) takes the total of the items of its argument.  What verb would add up the items in each row of an array?  What shape would the result have if it were applied to the array (d) shown below?
)
dl =: 2 dissect '3 1 3 |."0 1 c'
]d =: i. 4 5

NB. =========================================================
Lab Section Implicit verb rank
The argument had 4 rows, and each is totaled to produce an atom, so the shape of the result is (4).

Every J primitive has an "implicit rank" - the rank that is used if the verb is not modified by ("n).  You need to learn the rank when you learn a new verb, just as you need to learn the gender of a new Latin or German noun.

When a verb is applied to a noun whose rank exceeds the implicit rank, the verb is automatically applied to cells with the implicit rank, and the results are assembled.

A verb can have infinite implicit rank, which means that it always applies to its argument in its entirety.  Verbs created by (verb define) have infinite rank.

In general, a verb is responsible for handling any argument whose rank is less than or equal to the implicit rank.  Thus, the (%.) verb, which operates on tables [as matrices], has implicit rank 2 and is defined to operate on lists too.  The arithmetic verbs such as (+) have rank 0, i. e. they operate on atoms, and their application to larger arrays is entirely through the rank mechanism discussed above.

Verbs that operate on an entire array, such as ($) which gives its shape or (|.) which reverses the order of items, have infinite rank.
)
destroy__dl''
dl =: 2 dissect '+/"1 d'

NB. =========================================================
Lab Section Other loops
The rank mechanism provides way of matching computation to data: by applying a verb to cells of the appropriate size.

J has about a dozen other ways to rearrange data for computation.  We will examine these in later chapters, and with examples as we go along.
)
destroy__dl''



NB. =========================================================
Lab Chapter Read CSV file
NB. =========================================================
Lab Section CSV files
A CSV file is a representation of a spreadsheet.  The name stands for 'comma-separated values', and indicates that fields are separated by commas, and lines by LF [newline or end-of-line] characters.

The edit window shows the sample CSV file we will work with.

The program we want will read in a CSV file and convert it to a form usable in J.
)
open jpath '~addons/labs/labs/core/example.csv'
NB. =========================================================
Lab Section Designing the program
The first decision is the input and output of the program.

For maximum flexibility, the input will be the text of the file.  Each line will be terminated with LF.  On some operating systems there may be CR characters which we will discard.

The result will be a collection of fields, each of which is a string.  But these fields cannot be assembled as is into a single array, because J arrays require that each item have the same shape and type.  If a short string is joined to a long string in a single array, the short string will be padded with spaces.

When you need a heterogeneous array, you use boxing.  A box is treated as an atom, but it has contents that can have any shape or type.  If you want an array of different-sized strings, put each one in a box first and then make an array of the boxes.

Similarly, each line of the CSV file might contain a different number of fields, so the lines must not be joined into a single array.  Each line must be boxed first.

So, the result will be a list of boxes, one for each line of the CSV file; each boxes will contain a list of boxes, one for each field in the line.
)

NB. =========================================================
Lab Section Design cont'd: quotes
Reading the details at
http://en.wikipedia.org/wiki/Comma-separated_values
reveals that double-quote ["] characters are used to enclose fields that contain special characters, and that the special characters are " itself, comma, and LF [linefeed or end-of-line].

Since LF may appear in a quoted field, we must not start the program by splitting the data at each LF character.  Rather, at each stage of processing we need to treat a special character as special only if it is preceded by an odd number of " characters.

The final program is shown in the edit window.
)
PREPARE
opendebscript 1!:1 < jpath '~addons\labs\labs\core\splitcsv.ijs'
PREPARE

NB. =========================================================
Lab Section Audit input
The first thing to do is to check the input: remove any CR characters that the operating system put in, and make sure the file ends with LF.
)
splitcsv 1!:1 < jpath '~addons\labs\labs\core\example.csv'

NB. =========================================================
Lab Section Split into lines
(;._2) is a partitioning modifier.  It is applied to a verb to its left.  The whole compound is then (u;._2) where (u) is any verb you like.  (u) will be applied on selected portions of the right argument.  Each such selected portion is called a partition.

Here, the verb is (<) which means each partition will be put into a box.

The verb (<;._2) is executed here with a left and a right argument.  The left argument has a 1 in the position of each unquoted LF character; the right argument is the file data; the result is to box each line.

Let's see how that mask of LF positions was calculated.
)
debugstep''
NB. =========================================================
Lab Section Find parity of " characters
('"' = y) creates a 1 for each LF and a 0 for each non-LF.

(~:/\) is another partitioning modifier: (u\ y) executes (u) on prefixes of y of increasing length: first on just the first item of y, then on the first 2 items, then the first 3, and so on, collecting the results from the prefixes together into its final result.

Here the (u) is (+/), which adds up the items of its argument.

Thus, (+/\ y) computes, for each item of (y), the total number of " characters up to and including that item.

(x | y) takes the remainder of dividing (y) by (x); (2 | y) produces 1 if (y) is odd, 0 if (y) is even.

(|.!.0 y) shifts (y) one position to the right, bringing in a 0 to the vacated position.  So the result is 1 if an item of (y) is preceded by an odd number of 1s.

[Note: experienced J programmers would use (~:/\) rather than (2 | +/\)] 
)
debugstep''

NB. =========================================================
Lab Section Find unquoted delimiters
(x E. y) produces a result with the shape of (y), with 1 at points in (y) that match (x), and 0 elsewhere.

(-. y) is Boolean negation.

(x *. y) is Boolean AND.

So this line produces a 1 in the location of every delimiter (x) [LF in this case], except in positions that are preceded by an odd number of " characters.

[Rather than ((-. parity) *. y) we could have used (parity < y).] 
)
debugstep''

NB. =========================================================
Lab Section Split each line
Now each line has been put into its own box.  All that remains is to process each line, splitting it at commas.

The verb (splitline) will do that for one line.  To apply (splitline) to the contents of each boxed line, we use the (each) modifier.  (each) is an adverb, which means that it applies to the verb to its left.  (splitline each y) will open each atom of (y), apply (splitline) to the contents, and then put the result into a box.  In other words, (splitline each y) applies (splitline) inside each box of (y).

We will follow splitline through one execution. 
)
debugstep''

NB. =========================================================
Lab Section Split the line at commas
We calculate the position of unquoted commas, and split the line there.  This is similar to the way we split the file into lines.

We are careful to add an extra ending delimiter to the line, so that even if it doesn't end with a comma, the last characters will be put into a box.
)
0 debugchangestops 'delim'
debugstep''

NB. =========================================================
Lab Section Remove outer quotes
Any field that begins with a " character should have the outer " characters removed.  They must be the first and last characters.

Again we use (each) to operate inside the boxes for the fields.

The sequence (u^:v y), where (u) and (v) are verbs, is the Dynamic If sequence.  It means 'apply (u) IF (v) produces 1, but not if (v) produces 0'.  So, if (v) produces 0, the result of (u^:v y) is (y), while if (v) produces 1, the result is (u y).

In other words, the result is (y) but with (u) applied to it if (v) produced TRUE.

The Dynamic If is better than an (if.-do.-end.) sequence because Dynamic If is an expression rather than a statement, and can be applied to each item of an array with different results from the test-verb (v).  Here, the decision of whether to remove the " characters is made for each box independently.
)
debugstep''

NB. =========================================================
Lab Section Remove escaped quotes
Any sequence of "" characters represents an escaped quote.  We find these, and the create a mask of all the characters that are NOT escaped quotes.  We give this mask to the verb (x # y) to preserve any character that was not an escaped quote.
)
debugstep''

NB. =========================================================
Lab Section Finish up
All that remains is to apply the formatting verb to each line.

The result of the verb is shown.
)
0 debugchangestops ;: 'splitline splitcsv'
debugrun''
debugstop''



NB. =========================================================
Lab Chapter Five Number Summary
NB. =========================================================
Lab Section The Program
The Five Number Summary is a rough-and-ready way of characterizing a dataset.  It is described at 
http://en.wikipedia.org/wiki/Five-number_summary

Our input will be the name of a CSV file created by a spreadsheet program.  The first row will contain titles, and subsequent rows will contain one dataset per row.  The titles will contain one title 'Data'.  That column, and all following columns, are the numeric observations for the dataset.  All columns before the 'Data' column are descriptive labels for the dataset, which will be copied over into the output.

Our output will be a CSV file.  The first line will be copied from the input, except that the 'Data' column and after will be replaced with headers for the Five Number Summary.  Subsequent lines will contain the descriptive labels, followed by the Five Number Summary for each row.

The program is shown in the edit window.
)
PREPARE
opendebscript 0 : 0
NB. Five Number Summary
NB. y is filename (string) of a CSV file
NB.  We read in the file and break it into comma-delimited fields
NB.  The first line is headers
NB.    The 'Data' header marks the start of the observations
NB.  Remaining lines are datasets
NB.    Columns before 'Data' are labels, which are preserved
NB.    in the output
NB.    Columns starting with 'Data' are replaced by the
NB.    Five Figure Summary
NB.    Empty values are ignored
NB. Result is comma-delimited string, suitable for writing
NB.  to a CSV file; or empty string, if there was an error
fivenumbercsv =: verb define
NB.~stop fivenum
NB.~title 3	Five Number Summary of CSV File
NB.~title1 0	Read and convert the file
NB.~link0 0	Five Number Summary	http://en.wikipedia.org/wiki/Five-number_summary
NB.~link1 0	I/O Verbs	http://www.jsoftware.com/jwiki/Vocabulary/Foreigns#m1
NB. Read the file, convert to CSV format
boxedfields =. splitcsv 1!:1 < jpath y
NB.~title1 0	Take first line
NB.~link1
NB. Extract header line
header =. > {. boxedfields
NB.~title1 0	Find position of 'Data'
NB. Find position of 'Data' header (error if omitted)
datax =. header i. <'Data'
NB.~title1 0	Exit if no 'Data'
if. datax = #header do. '' return. end.
NB.~title1 0	Remove empties, convert to numeric
NB.~link1 0	each	http://www.jsoftware.com/jwiki/Vocabulary/ampdot
NB. Remove empties; convert the data to numeric (__ if invalid data); leave data as numeric list
datafields =. {.@(__&".)@> each  (-.&a:) each datax }. each }. boxedfields
NB.~title1 0	Check for errors in conversion
NB.~link1 0	if. blocks	http://www.jsoftware.com/jwiki/Vocabulary/TBlock
if. __ e. ; datafields do. '' return. end.
NB.~title1 0	Calculate FNS
NB.~link1 0	each	http://www.jsoftware.com/jwiki/Vocabulary/ampdot
NB. Take the five-number summary of each line
NB. This returns 5 numbers or none for each line
NB.  (none if there are no numbers)
fns =. fivenumbersumm each datafields
NB.~title1 0	Join headers & labels to FNS
NB.~link1
NB. Append headers to summaries, and summaries to line labels.
NB. Convert numbers to string form
reslines =. (datax {.&> boxedfields) ,. ('Min';'Q1';'Median';'Q3';'Max') , ":each@> fns
NB.~title1 0	Format result as CSV
NB.~link1 0	each	http://www.jsoftware.com/jwiki/Vocabulary/ampdot
NB.~link2 0	Fork	http://www.jsoftware.com/jwiki/Vocabulary/fork
NB. Convert each row to CSV, append LF, run lines together
; <@(LF _1} ;)"1 (addquote each reslines) , each ','
))

NB. y is a string
NB. result s the same string, but any " characters are doubled,
NB. and if the string contains , or " it is enclosed in "
addquote =: verb define
NB.~stop addquote
NB.~title 3	Convert field to CSV format
NB.~title1 0	Escape embedded quotes
NB. Double any " characters
escquotes =. (>: '"' = y) # y
NB.~title1 0	Test for special character
NB.~link0 0	if. blocks	http://www.jsoftware.com/jwiki/Vocabulary/TBlock
NB. Enclose in quotes if value contains special character
if. +./ (',"',LF) e. y do.
NB.~title1 0	Enclose line in quotes
NB.~link0
  escquotes =. '"' , escquotes , '"'
end.
escquotes
))


NB. y is a list of numbers
NB. Result is Five Number Summary (a list of 5 numbers)
NB. but if there are no numbers in y, return empty numeric list
fivenumbersumm =: verb define
NB.~stop fivenumsumm
NB.~title 3	Five Number Summary
NB.~title1 0	Check for empty input
NB.~link0 0	Five Number Summary	http://en.wikipedia.org/wiki/Five-number_summary
if. 0 = #y do. 0$0 return. end.
NB.~title1 0	Calculate percentile positions
NB. Calculate indices of the 5 percentiles
index =. (<:#y) * 0 0.25 0.5 0.75 1
NB.~title1 0	Calculate index of lower value
NB. The integer part of the index is the lower number to use
fetchlo =. <. index
NB.~title1 0	Calculate weighting for upper & lower values
NB. The fractional part of the index is the amount of the
NB. upper number to use; 1-that is the amount of the lower number to use.
NB. For example, an index of 4.25 will take 0.75 times value 4
NB. and 0.25 times value 5
NB. Create (upper weight,lower weight) for each result: a 5x2 table
weights =. (,.   -.) (index - fetchlo)
NB.~title1 0	Sort inputs, fetch value, weight
NB.~link1 0	Sort	http://www.jsoftware.com/jwiki/Vocabulary/slashco#dyadic
NB.~link2 0	Table	http://www.jsoftware.com/jwiki/Vocabulary/slash#dyadic
NB. Sort the inputs into order.
NB. Fetch (upper value, lower value) for each result, multiply by
NB. weight, and add.  We have to add on an extra value at the end
NB. for the last (=maximum) result (it will have a weight of 0)
+/"1 weights * (fetchlo +/ 1 0) { (/:~y),0
))
)
PREPARE
load '~addons\labs\labs\core\splitcsv.ijs'

NB. =========================================================
Lab Section Read the CSV file
First we read the file, and then use the splitcsv program we wrote earlier to parse it.

(1!:1) is a verb, in fact a verb to read a file.  (!:) is a conjunction, meaning it takes two operands, which can be nouns or verbs, on its left and right, and produces any part of speech.

This is different from a verb which takes one or two arguments which must be nouns, and produces a result that must be a noun.

We have seen conjunctions before, for example in (<;._2) where the conjunction was (;.) and the operands were (<) and (_2), and the result (<;._2) was a verb that chopped up its (y) argument and put the pieces in boxes.

The result of executing the conjunction [(;.) above] is usually a verb.  This result [(<;._2) above] is called the derived verb.  The derived verb will itself be executed when it is presented with arguments.

The description of the conjunction in NuVoc is mainly a description of the derived verb.


The (!:) conjunction gives access to a grab-bag of useful features that are not important enough to get their own ASCII primitive.  Many of them perform actions that are considered outside the J language, such as operating-system requests, DLL calls, and file I/O.  Such actions are called "foreign".

The foreign functions are accessed by number.  (!:) is invoked by giving it two numbers (m) and (n), as in (m!:n).  The numbers are arbitrary, but generally functions with the same value of (m) are somewhat related.  The supported values of (m) and (n) are shown in a NuVoc page.

The foreign function used here, (1!:1), reads the file named by (y) and produces as result an array containing the bytes of the file.


The library function (jpath) resolves the name ('~addons') to its location on your system.
)
fivenumbercsv '~addons\labs\labs\core\fivenum.csv'

NB. =========================================================
Lab Section Extract header line
Since the first line is special, containing headers, we pull it out by itself, and remove the outer boxing.
)
debugstep''

NB. =========================================================
Lab Section Locate 'Data' header
We search in the headers to find 'Data', saving the index value at which it is found.

If the value is not found, the result is the number of headers, which is one more than the last valid index.
)
debugstep''

NB. =========================================================
Lab Section Verify 'Data' present
If the 'Data' field is not given, we have to abort with an error indication.

The (return.) control word ends execution of a verb, just as if the verb ran to the end.  As always, the result of the last sentence executed becomes the result of the verb.  So, the sentence producing the return value, ('') here, is executed just before the (return.).

But our data file contains 'Data', so the condition tests false (0) and we keep going.
)
debugstep''

NB. =========================================================
Lab Section Remove empties, convert to numeric
(}. y) removes the first item of (y); in this case, it removes the header line, leaving all the data lines, each a list of boxed fields inside an outer box.

(x }. y) removes the (x) leading items of (y).  Since we apply (each) to (}.), with (}. each), this operation is performed inside the boxes.  In other words, we delete the columns before the 'Data' column.

(x -. y) deletes items of (x) that match (y).  We want to remove any empty fields, that is, we want to remove any fields in a line that match (a:) which is a box containing an empty list.

But note: we can't simply write

(lines -. each a:)

because that would apply the (-.) to the contents of each argument - but we don't want the contents of (a:), we want the boxed (a:).  The solution is to create a verb

(-.&a:)

which means 'remove (a:) from (y)'.  (-.&a: y) is equivalent to (y -. a:).  The (&) bonds the noun (a:) to the verb (-.) to produce a new verb (-.&a:) in which the (a:) is automatically supplied as the right argument of (-.).  We apply this verb inside the boxes.

Converting the boxed strings to unboxed numbers is similar.  The verb is

({.@(__&".)@> each)

(u@v y) means 'apply (v) to a cell of (y), then apply (u).'

(__ ". y) means 'convert y from character to numeric, and if there is an error in the conversion, use (__) for the erroneous value'.  We use (&) as we did above to create a bonded verb that automatically supplies (__) as the left argument of (".).

({. y) takes the first item of (y).  This is a protection against ill-formed fields that produce 0 or more than 1 number.

Thus, the verb ({.@(__&".)@> each) means, 'go inside each box; then, open each box you find and convert the contents to numeric, using (__) as the value if there is a conversion error; and take only one number.'  The result inside each box will be a list of numbers rather than a list of boxes.

)
debugstep''

NB. =========================================================
Lab Section Check for errors
(datafields) is a list of boxes, each containing a list of numbers.  If any of these numbers is (__), there was an erroneous value and we need to abort.

(; datafields) runs the contents of (datafields) together in one list.

(__ e. y) returns 1 if (__) is found as an item of (y).
)
debugstep''

NB. =========================================================
Lab Section Calculate Five Number Summary
For each contents of (datafields), we want to calculate the Five Number Summary.
)
debugstep''

NB. =========================================================
Lab Section FNS: check for empty input
If there are no numbers, no reasonable summary is possible.  Return an empty result in that case.
)
debugstep''

NB. =========================================================
Lab Section FNS: calculate percentile positions
Each result value is a blend between two adjacent data values in the sorted input data.

For example, if there are 6 values in (y), the median is the average of values 2 and 3 [the middle values].

Generally, we calculate a value int.frac [it would be 2.5 in the example above] which means blend between values (int) and (int+1), giving weight (frac) to value (int+1) and weight (1-frac) to value (int).
)
debugstep''

NB. =========================================================
Lab Section FNS: index of lower value
We save the integer parts of the int.frac values as the indexes to the lower blended values
)
debugstep''

NB. =========================================================
Lab Section FNS: weights of upper,lower values
The weight for the upper value is the fractional part of the int.frac form, which we extract be subtracting away the integer part.

Each number thus produced needs to be converted into a list of two numbers: (frac) needs to turn into (frac , 1-frac).

The form (u v) where (u) and (v) are verbs is called a hook.  The two verbs adjacent have no normal meaning, so J defines that ((u v) y) means (y u v y).

So here, ((,.  -.) frac) means (frac ,. -. frac).

(-. y) means (1-y).

(x ,. y) joins corresponding items of (x) and (y) together.

The result is a 5x2 array of (frac , 1-frac) for each result number.
)
debugstep''

NB. =========================================================
Lab Section FNS: Sort, fetch, and weight
(/:~ y) sorts (y) into ascending order.  We have to append one more unused value, since the maximum value is always going to have the index (last.0) and will fetch values at (last) and (last+1)

(fetchlo +/ 1 0) uses (+/) which produces an addition table, the 5x2 table where each row uses (fetchlo) and each column uses (1 0).

The verb ({) extracts the 5x2 array of selected values.

These values are multiplied by the calculated weights.

Then the total is taken across each row, which for each result number adds the two contributing weighted values.  This gives the final five-number result.
)
debugstep''

NB. =========================================================
Lab Section Append headers and non-data columns
At this point (fns) is a list of boxes, each containing a five-number summary (unless there were no numbers to begin with, in which case the contents are empty.

First we want to convert this to a table of boxed strings, one for each number.  This means we want to remove the boxing around each box of (fns), and then, for each number, convert it to characters and box it so that the different-length numbers are not coerced into the same array.

These lines, 5 numbers each, will be collected into a table of boxes, 5 columns wide.

Any box of (fns) that was empty will not have 5 boxed numbers to contribute.  J will add empty boxes to fill out the array.  This empty box is called (a:) and is equivalent to (<0$0).  We will see a row with 5 empty fields.

The verb to do all this is (":each@>) which unboxes each box and then applies (":), which converts numerics to string form, on each individual number, leaving the result in its own box.

Next is to append headings to the five-number summary, using (,).

Next, we preserve the part of the original input that was to the left of the data, using (datax {.&> boxedfields) which takes the first (datax) items from each contents of (boxedfields).  The (boxedfields) were in boxes because there were varying numbers of them per line, but now that we have squared off the array we can dispense with the outer boxing, leaving a table (datax) columns wide.

Finally, we join the two tables together using (,.) which appends corresponding rows.
)
0 debugchangestops 'fivenumsumm'
debugstep''

NB. =========================================================
Lab Section Format the result as CSV
The final result will be a string with commas between fields and LF between lines.

Fields containing special characters will have to be escaped and enclosed in " characters.  We delegate that to the verb (addquote) and we use (each) so that the string is properly formatted inside its own box.

Next we add a comma after each field, converting (123.45) to (123.45,).  This produces all the comma delimiters, plus one extra one at the end of the line.

Then we format each row, using the verb (<@(LF _1} ;)"1).  The ("1) indicates that the verb is to be applied to a 1-cell of the data, i. e. a single row of boxes.

For each row, we perform (LF _1} ;) which uses (;) to run the contents of the boxes into a single string and then (_1}) to replace the last character with (LF).  This removes the extra unwanted comma and replaces it with the needed line-separator.

Since the resulting strings have varying length, we enclose each one in a box.

Finally, we use (;) to run all the lines together into the final result string.
)
debugstep''

NB. =========================================================
Lab Section Escape quote characters by doubling them
Here we follow the execution of (addquote).

First, we have to replace each " character by "" .   We do this be creating a list that contain 2 for each " character and 1 for each non-quote, and using (x # y) to create a string containing (x) copies of each item of (y).
)
debugstep''

NB. =========================================================
Lab Section Enclose in quotes if necessary
We use (e.) to check each special character for inclusion in (y).  We then use (+./) to OR together those results, producing 1 if the field contained a special character.

If the field did, we enclose it in quotes.
)
debugstep''

NB. =========================================================
Lab Section completion
The final result of (fivenumbercsv) is the string representing the CSV file.
)
0 debugchangestops ;:'addquote fivenum'
debugrun''
debugstop''
